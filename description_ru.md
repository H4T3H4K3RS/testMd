# Общее

Это код `C++`, который реализует вейвлет-преобразование Хаара и его обратное, а также несколько функций сокращения, таких как мягкое сокращение, жесткое сокращение и сокращение Гарро. Вейвлет-преобразование используется для разложения изображения на различные частотные поддиапазоны, что может быть полезно для сжатия изображения и выделения признаков. Функции сжатия используются для порога вейвлет-коэффициентов, уменьшая шум и нежелательные детали изображения. В коде также есть функция для итеративного применения вейвлет-преобразования для получения многомасштабного представления изображения, что может быть полезно для сегментации и анализа изображения.

Функция `cvHaarWavelet` принимает входное изображение, выходное изображение и количество итераций в качестве входных данных и итеративно применяет вейвлет-преобразование Хаара к входному изображению, сохраняя результат в выходном изображении. Функция `cvInverseHaarWavelet` принимает те же входные данные и выполняет обратное вейвлет-преобразование для восстановления исходного изображения.

Функции `soft_shrink`, `hard_shrink` и `Garrot_shrink` принимают значение и пороговое значение в качестве входных данных и применяют соответствующую функцию сжатия к значению на основе порогового значения. Функция sign возвращает знак входного значения.

Вы можете использовать этот код для выполнения вейвлет-преобразования и сжатия ваших собственных изображений, но вы должны убедиться, что изображение имеет тип `CV_32FC1`, а размер входного и выходного изображения должен совпадать. Кроме того, вы можете настроить количество итераций и пороговое значение для получения желаемых результатов.

# Детальное

```c++
#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <stdio.h>

using namespace cv;
using namespace std;

// Filter type
#define NONE 0  // no filter
#define HARD 1  // hard shrinkage
#define SOFT 2  // soft shrinkage
#define GARROT 3  // garrot filter
```
Этот код включает библиотеку `OpenCV` и другие необходимые библиотеки, такие как `iostream`, `vector` и `stdio.h`. Он также определяет некоторые макросы препроцессора для различных типов доступных фильтров сжатия.
```c++
//--------------------------------
// signum
//--------------------------------
float sgn(float x)
{
    float res=0;
    if(x==0)
    {
        res=0;
    }
    if(x>0)
    {
        res=1;
    }
    if(x<0)
    {
        res=-1;
    }
    return res;
}
```
Функция `sign` принимает число с плавающей запятой в качестве входных данных и возвращает его знак. Если вход равен нулю, он возвращает ноль, если он положительный, он возвращает `1`, а если отрицательный, он возвращает `-1`.
```c++
//--------------------------------
// Soft shrinkage
//--------------------------------
float soft_shrink(float d,float T)
{
    float res;
    if(fabs(d)>T)
    {
        res=sgn(d)*(fabs(d)-T);
    }
    else
    {
        res=0;
    }

    return res;
}
```
Функция `soft_shrink` принимает значение `d` и пороговое значение `T` в качестве входных данных и применяет к ним фильтр мягкого сжатия. Он проверяет, превышает ли абсолютное значение `d` пороговое значение `T`, и если да, то оно вычитает `T` из абсолютного значения `d` и умножает его на знак `d`. В противном случае он возвращает `0`.
```c++
//--------------------------------
// Hard shrinkage
//--------------------------------
float hard_shrink(float d,float T)
{
    float res;
    if(fabs(d)>T)
    {
        res=d;
    }
    else
    {
        res=0;
    }

    return res;
}
```
Функция `hard_shrink` принимает значение `d` и пороговое значение `T` в качестве входных данных и применяет к ним фильтр жесткого сжатия. Он проверяет, превышает ли абсолютное значение `d` пороговое значение `T`, если да, то возвращает исходное значение `d`, иначе возвращает `0`.
```c++
//--------------------------------
// Garrot shrinkage
//--------------------------------
float Garrot_shrink(float d,float T)
{
    float res;
    if(fabs(d)>T)
    {
        res=d-((T*T)/d);
    }
    else
    {
        res=0;
    }

    return res;
}
```
Функция `Garrot_shrink` принимает значение `d` и пороговое значение `T` в качестве входных данных и применяет к ним фильтр сжатия Гаррота. Он проверяет, превышает ли абсолютное значение `d` пороговое значение `T`, и если да, то вычитает `(T*T)/d` из исходного значения `d`. В противном случае он возвращает `0`.
```c++
//--------------------------------
// Wavelet transform
//--------------------------------
static void cvHaarWavelet(Mat &src,Mat &dst,int NIter)
{
    float c,dh,dv,dd;
    assert( src.type() == CV_32FC1 );
    assert( dst.type() == CV_32FC1 );
    int width = src.cols;
    int height = src.rows;
    for (int k=0;k<NIter;k++)
    {
        for (int y=0;y<(height>>(k+1));y++)
        {
            for (int x=0; x<(width>>(k+1));x++)
            {
                c=(src.at<float>(2*y,2*x)+src.at<float>(2*y,2*x+1)+src.at<float>(2*y+1,2*x)+src.at<float>(2*y+1,2*x+1))*0.5;
                dst.at<float>(y,x)=c;

                dh=(src.at<float>(2*y,2*x)+src.at<float>(2*y+1,2*x)-src.at<float>(2*y,2*x+1)-src.at<float>(2*y+1,2*x+1))*0.5;
                dst.at<float>(y,x+(width>>(k+1)))=dh;

                dv=(src.at<float>(2*y,2*x)+src.at<float>(2*y,2*x+1)-src.at<float>(2*y+1,2*x)-src.at<float>(2*y+1,2*x+1))*0.5;
                dst.at<float>(y+(height>>(k+1)),x)=dv;

                dd=(src.at<float>(2*y,2*x)-src.at<float>(2*y,2*x+1)-src.at<float>(2*y+1,2*x)+src.at<float>(2*y+1,2*x+1))*0.5;
                dst.at<float>(y+(height>>(k+1)),x+(width>>(k+1)))=dd;
            }
        }
        dst.copyTo(src);
    }
}
```
Функция `cvHaarWavelet` является реализацией вейвлет-преобразования Хаара. Эта функция принимает исходное изображение `src`, целевое изображение `dst` и количество итераций `NIter` в качестве входных данных. Он применяет вейвлет-преобразование Хаара к исходному изображению `src` и сохраняет результат в целевом изображении `dst`. Он использует вложенный цикл для указанного количества итераций, на каждой итерации он применяет вейвлет-преобразование Хаара к исходному изображению и сохраняет результаты в целевом изображении.
```c++
//--------------------------------
//Inverse wavelet transform
//--------------------------------
static void cvInverseHaarWavelet(Mat &src,Mat &dst,int NIter)
{
    float c,dh,dv,dd;
    assert( src.type() == CV_32FC1 );
    assert( dst.type() == CV_32FC1 );
    int width = src.cols;
    int height = src.rows;
    for (int k=0;k<NIter;k++)
    {
        for (int y=0;y<(height>>k);y++)
        {
            for (int x=0; x<(width>>k);x++)
            {
                c=src.at<float>(y,x);
                dh=src.at<float>(y,x+(width>>(k)));
                dv=src.at<float>(y+(height>>(k)),x);
                dd=src.at<float>(y+(height>>(k)),x+(width>>(k)));

                dst.at<float>(2*y,2*x)=c+dv+dh+dd;
                dst.at<float>(2*y,2*x+1)=c-dv+dh-dd;
                dst.at<float>(2*y+1,2*x)=c+dv-dh-dd;
                dst.at<float>(2*y+1,2*x+1)=c-dv-dh+dd;
            }
        }
        dst.copyTo(src);
    }
}
```
Функция `cvInverseHaarWavelet` является реализацией обратного вейвлет-преобразования Хаара. Эта функция принимает исходное изображение `src`, целевое изображение `dst` и количество итераций `NIter` в качестве входных данных. Он применяет обратное вейвлет-преобразование Хаара к исходному изображению `src` и сохраняет результат в целевом изображении `dst`. Он использует вложенный цикл для указанного количества итераций, на каждой итерации он применяет обратное вейвлет-преобразование Хаара к исходному изображению и сохраняет результаты в целевом изображении.
```c++
int main( int argc, char** argv )
{
    Mat src,dst;
    int filterType=0;
    float T=0.1;
    int NIter=3;
    src = imread( argv[1], 1 );
    if( !src.data )
    { return -1; }
    dst = src.clone();
    if(filterType==HARD)
    {
        for (int i=0;i<src.rows;i++)
        {
            for (int j=0;j<src.cols;j++)
            {
                dst.at<float>(i,j)=hard_shrink(src.at<float>(i,j),T);
            }
        }
    }
    else if(filterType==SOFT)
    {
        for (int i=0;i<src.rows;i++)
        {
            for (int j=0;j<src.cols;j++)
            {
                dst.at<float>(i,j)=soft_shrink(src.at<float>(i,j),T);
            }
        }
    }
    else if(filterType==GARROT)
    {
        for (int i=0;i<src.rows;i++)
        {
            for (int j=0;j<src.cols;j++)
            {
                dst.at<float>(i,j)=Garrot_shrink(src.at<float>(i,j),T);
            }
        }
    }
    cvHaarWavelet(dst,dst,NIter);
    cvNamedWindow( "src", 1 );
    cvNamedWindow( "dst", 1 );
    cvShowImage( "src", &IplImage(src));
    cvShowImage( "dst", &IplImage(dst));
    cvWaitKey();
    return 0;
}
```
Здесь он проверяет тип выбранного фильтра (жесткий, мягкий или гаррот) и применяет соответствующий фильтр сжатия к целевому изображению, используя вложенные циклы. Затем он применяет вейвлет-преобразование Хаара к целевому изображению, используя функцию `cvHaarWavelet` и указанное количество итераций. Затем он применяет обратное вейвлет-преобразование Хаара к целевому изображению, используя функцию cvInverseHaarWavelet и указанное количество итераций. Наконец, он отображает исходное и целевое изображения и ожидает нажатия клавиши.

Стоит отметить, что код написан с использованием старого `API OpenCV` в стиле `C`, он может быть несовместим с последней версией `OpenCV` и может не работать как есть.
